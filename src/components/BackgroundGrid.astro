---
/**
 * Responsive, flicker-free checkerboard background
 * Works for dark and light modes
 * Uses CSS variables from global.css
 */
---

<div class="bg-grid-root">
  <canvas id="bg-grid-canvas" aria-hidden="true"></canvas>
</div>

<style>
.bg-grid-root {
  position: fixed;
  inset: 0;
  z-index: -10;
  pointer-events: none;
}

#bg-grid-canvas {
  width: 100%;
  height: 100%;
  display: block;
}
</style>

<script type="module">
(() => {
  const canvas = document.getElementById("bg-grid-canvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;

  let width, height, dpr;
  const cellSize = 64;
  const scrollSpeed = 0.2;
  const diagonal = true;

  // Helper: parse hex or rgba color to [r,g,b,a]
  function parseColor(color) {
    color = color.trim();
    if (color.startsWith('#')) {
      let r = parseInt(color.slice(1,3),16);
      let g = parseInt(color.slice(3,5),16);
      let b = parseInt(color.slice(5,7),16);
      return [r,g,b,1];
    } else if (color.startsWith('rgba')) {
      return color.match(/\d+\.?\d*/g).map(Number);
    } else if (color.startsWith('rgb')) {
      return [...color.match(/\d+/g).map(Number),1];
    }
    return [0,0,0,1];
  }

  // Helper: interpolate two arrays
  function lerpArr(a, b, t) {
    return a.map((v,i)=> v + (b[i]-v)*t);
  }

  // Helper: array to rgba string
  function rgbaStr(arr) {
    return `rgba(${Math.round(arr[0])},${Math.round(arr[1])},${Math.round(arr[2])},${arr[3]})`;
  }

  let rootStyles = getComputedStyle(document.documentElement);
  let targetA = parseColor(rootStyles.getPropertyValue('--bg-grid-color-a'));
  let targetB = parseColor(rootStyles.getPropertyValue('--bg-grid-color-b'));

  let currentA = [...targetA];
  let currentB = [...targetB];
  const transitionSpeed = 0.08;

  let offsetX = 0;
  let offsetY = 0;

  function resize() {
    dpr = Math.max(1, window.devicePixelRatio || 1);
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function draw() {
    // Interpolate colors
    currentA = lerpArr(currentA, targetA, transitionSpeed);
    currentB = lerpArr(currentB, targetB, transitionSpeed);

    ctx.clearRect(0,0,width,height);
    const cols = Math.ceil(width/cellSize)+2;
    const rows = Math.ceil(height/cellSize)+2;

    for (let y=-1;y<rows;y++){
      for (let x=-1;x<cols;x++){
        const isDark = (x+y)%2===0;
        ctx.fillStyle = isDark ? rgbaStr(currentA) : rgbaStr(currentB);
        const px = Math.round(x*cellSize+offsetX);
        const py = Math.round(y*cellSize+offsetY);
        ctx.fillRect(px, py, cellSize, cellSize);
      }
    }

    if(diagonal){
      offsetX -= scrollSpeed;
      offsetY -= scrollSpeed;
    } else {
      offsetX -= scrollSpeed;
    }

    if(offsetX <= -cellSize) offsetX += cellSize;
    if(offsetY <= -cellSize) offsetY += cellSize;

    requestAnimationFrame(draw);
  }

  resize();
  draw();
  window.addEventListener("resize", resize, {passive:true});

  // Observe dark mode toggle
  const observer = new MutationObserver(()=>{
    rootStyles = getComputedStyle(document.documentElement);
    targetA = parseColor(rootStyles.getPropertyValue('--bg-grid-color-a'));
    targetB = parseColor(rootStyles.getPropertyValue('--bg-grid-color-b'));
  });
  observer.observe(document.documentElement, {attributes:true, attributeFilter:['class']});
})();
</script>
